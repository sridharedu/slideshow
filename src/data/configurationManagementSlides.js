export const configurationManagementSlides = [
  {
    title: "What is Configuration Management?",
    points: [
      "‚úîÔ∏è Centralized management of application configuration across environments",
      "Separates configuration from code for better maintainability",
      "Enables dynamic configuration updates without redeployment",
      "üî• Essential for microservices and cloud-native applications"
    ],
    note: "üß† Configuration Management = External, environment-specific settings",
    keepInMind: "Configuration should be externalized to enable the same artifact to run in different environments."
  },
  {
    title: "Why Configuration Management?",
    points: [
      "**Problems without Centralized Config:**",
      "‚Ä¢ Configuration scattered across multiple files",
      "‚Ä¢ Environment-specific builds and deployments",
      "‚Ä¢ Manual configuration updates across services",
      "‚Ä¢ Configuration drift between environments",
      "",
      "**Benefits:**",
      "‚Ä¢ Single source of truth for configuration",
      "‚Ä¢ Environment-agnostic deployments",
      "‚Ä¢ Dynamic configuration updates",
      "‚Ä¢ Configuration versioning and audit trails"
    ],
    keepInMind: "Centralized configuration enables true DevOps practices with consistent deployments across environments."
  },
  {
    title: "Configuration Management Patterns",
    points: [
      "```table",
      "Pattern | Description | Example",
      "Environment Variables | OS-level configuration | DATABASE_URL=jdbc:mysql://...",
      "Property Files | File-based configuration | application.properties",
      "Configuration Server | Centralized config service | Spring Cloud Config",
      "Service Discovery | Config via service registry | Consul KV store",
      "Cloud Config | Managed configuration service | AWS Parameter Store",
      "```"
    ],
    keepInMind: "This table shows various ways to manage configuration. Environment variables are simple and language-agnostic. Property files are common but can be scattered. A Configuration Server centralizes all settings, which is ideal for microservices. Each pattern has trade-offs between simplicity, scalability, and operational overhead."
  },
  {
    title: "Spring Cloud Config Overview",
    points: [
      "‚úîÔ∏è Centralized configuration management for distributed systems",
      "Git-backed configuration repository",
      "Environment-specific configuration profiles",
      "Dynamic configuration refresh without restart",
      "Integration with Spring Boot applications",
      "üî• De facto standard for Spring microservices configuration"
    ],
    keepInMind: "Spring Cloud Config treats configuration as code with version control and change tracking."
  },
  {
    title: "Config Server Setup",
    points: [
      "**Dependencies:**",
      "```xml",
      "<dependency>",
      "    <groupId>org.springframework.cloud</groupId>",
      "    <artifactId>spring-cloud-config-server</artifactId>",
      "</dependency>",
      "```",
      "**Main Class:**",
      "```java",
      "@SpringBootApplication",
      "@EnableConfigServer",
      "public class ConfigServerApplication {",
      "    public static void main(String[] args) {",
      "        SpringApplication.run(ConfigServerApplication.class, args);",
      "    }",
      "}",
      "```"
    ],
    keepInMind: "To create a Config Server, you need the `spring-cloud-config-server` dependency and the `@EnableConfigServer` annotation. This turns a regular Spring Boot application into a centralized configuration provider that serves settings from a backend like a Git repository."
  },
  {
    title: "Config Server Configuration",
    points: [
      "```yaml",
      "server:",
      "  port: 8888",
      "",
      "spring:",
      "  application:",
      "    name: config-server",
      "  cloud:",
      "    config:",
      "      server:",
      "        git:",
      "          uri: https://github.com/myorg/config-repo",
      "          clone-on-start: true",
      "          default-label: main",
      "        native:",
      "          search-locations: classpath:/config",
      "```",
      "üî• Supports Git, SVN, and native file system backends"
    ],
    keepInMind: "The `spring.cloud.config.server.git.uri` property points to the Git repository containing your configuration files. Using a Git backend is powerful as it provides versioning, branching, and auditability for all configuration changes."
  },
  {
    title: "Configuration Repository Structure",
    points: [
      "**Git Repository Layout:**",
      "```",
      "config-repo/",
      "‚îú‚îÄ‚îÄ application.yml          # Default config for all apps",
      "‚îú‚îÄ‚îÄ application-dev.yml      # Development environment",
      "‚îú‚îÄ‚îÄ application-prod.yml     # Production environment",
      "‚îú‚îÄ‚îÄ user-service.yml        # Service-specific config",
      "‚îú‚îÄ‚îÄ user-service-dev.yml    # Service + environment",
      "‚îî‚îÄ‚îÄ order-service.yml       # Another service config",
      "```",
      "**Naming Convention:**",
      "`{application}-{profile}.yml`"
    ],
    keepInMind: "The naming convention `{application}-{profile}.yml` allows for a clear hierarchy. `application.yml` provides global defaults, `user-service.yml` provides service-specific settings, and `user-service-dev.yml` provides settings for that service in the 'dev' environment."
  },
  {
    title: "Config Client Setup",
    points: [
      "**Dependencies:**",
      "```xml",
      "<dependency>",
      "    <groupId>org.springframework.cloud</groupId>",
      "    <artifactId>spring-cloud-starter-config</artifactId>",
      "</dependency>",
      "```",
      "**bootstrap.yml:**",
      "```yaml",
      "spring:",
      "  application:",
      "    name: user-service",
      "  cloud:",
      "    config:",
      "      uri: http://localhost:8888",
      "      fail-fast: true",
      "      retry:",
      "        initial-interval: 1000",
      "        max-attempts: 6",
      "```"
    ],
    keepInMind: "Client configuration goes in `bootstrap.yml` because it needs to be loaded before the main application context starts. This file tells the microservice where to find the Config Server (`spring.cloud.config.uri`)."
  },
  {
    title: "Configuration Properties",
    points: [
      "**Config Repository (user-service.yml):**",
      "```yaml",
      "app:",
      "  name: User Service",
      "  version: 1.0.0",
      "  features:",
      "    email-notifications: true",
      "    user-registration: true",
      "",
      "database:",
      "  url: jdbc:mysql://localhost:3306/userdb",
      "  username: user",
      "  password: '{cipher}AQA...'  # Encrypted",
      "```",
      "**Java Configuration Class:**",
      "```java",
      "@ConfigurationProperties(prefix = \"app\")",
      "@Component",
      "public class AppConfig {",
      "    private String name;",
      "    private String version;",
      "    private Map<String, Boolean> features;",
      "    // getters and setters",
      "}",
      "```"
    ],
    keepInMind: "`@ConfigurationProperties` provides a type-safe way to map external configuration to a Java object. This avoids scattering `@Value` annotations and makes configuration easier to manage and validate."
  },
  {
    title: "Dynamic Configuration Refresh",
    points: [
      "**Enable Refresh Endpoint:**",
      "```yaml",
      "management:",
      "  endpoints:",
      "    web:",
      "      exposure:",
      "        include: refresh,health,info",
      "```",
      "**Refreshable Configuration:**",
      "```java",
      "@RestController",
      "@RefreshScope",
      "public class UserController {",
      "    ",
      "    @Value(\"${\"app.name}\")",
      "    private String appName;",
      "    ",
      "    @GetMapping(\"/info\")",
      "    public String getInfo() {",
      "        return \"Application: \" + appName;",
      "    }",
      "}",
      "```",
      "**Trigger Refresh:**",
      "`POST /actuator/refresh`"
    ],
    keepInMind: "The `@RefreshScope` annotation on a bean signals that it can be re-initialized at runtime. When the `/actuator/refresh` endpoint is called, beans in this scope are destroyed and recreated, injecting the newly fetched configuration values."
  },
  {
    title: "Configuration Encryption",
    points: [
      "**Symmetric Encryption:**",
      "```yaml",
      "# Config Server",
      "encrypt:",
      "  key: mySecretKey",
      "```",
      "**Asymmetric Encryption:**",
      "```yaml",
      "encrypt:",
      "  key-store:",
      "    location: classpath:/config-server.jks",
      "    password: keystorepass",
      "    alias: config-server-key",
      "```",
      "**Encrypt Values:**",
      "```bash",
      "curl http://localhost:8888/encrypt -d 'mysecretpassword'",
      "# Returns: AQA1B2C3D4E5F6G7H8I9J0K1L2M3N4O5P6Q7R8S9T0",
      "```",
      "**Use in Config:**",
      "```yaml",
      "database:",
      "  password: '{cipher}AQA1B2C3D4E5F6G7H8I9J0K1L2M3N4O5P6Q7R8S9T0'",
      "```"
    ],
    keepInMind: "The Config Server provides `/encrypt` and `/decrypt` endpoints. You can encrypt sensitive values like passwords and commit the encrypted `{cipher}...` string to your Git repository, ensuring secrets are never stored in plain text."
  },
  {
    title: "Configuration Profiles",
    points: [
      "**Environment-Specific Profiles:**",
      "```yaml",
      "# application-dev.yml",
      "spring:",
      "  datasource:",
      "    url: jdbc:h2:mem:testdb",
      "logging:",
      "  level:",
      "    com.example: DEBUG",
      "",
      "# application-prod.yml",
      "spring:",
      "  datasource:",
      "    url: jdbc:mysql://prod-db:3306/app",
      "logging:",
      "  level:",
      "    com.example: WARN",
      "```",
      "**Activate Profile:**",
      "```yaml",
      "spring:",
      "  profiles:",
      "    active: dev",
      "```"
    ],
    keepInMind: "Spring Profiles are a core feature for managing environment-specific configurations. By setting `spring.profiles.active`, you control which property files are loaded, allowing the same application artifact to run with different settings in dev, QA, and prod."
  },
  {
    title: "Configuration with Service Discovery",
    points: [
      "**Config Server Registration:**",
      "```yaml",
      "# Config Server",
      "eureka:",
      "  client:",
      "    service-url:",
      "      defaultZone: http://localhost:8761/eureka",
      "```",
      "**Client Discovery:**",
      "```yaml",
      "# Client bootstrap.yml",
      "spring:",
      "  cloud:",
      "    config:",
      "      discovery:",
      "        enabled: true",
      "        service-id: config-server",
      "eureka:",
      "  client:",
      "    service-url:",
      "      defaultZone: http://localhost:8761/eureka",
      "```"
    ],
    keepInMind: "By registering the Config Server with Eureka and enabling discovery on the client, you no longer need to hardcode the Config Server's URI. The client will look up the `config-server` in Eureka, making the system more resilient and highly available."
  },
  {
    title: "Configuration Alternatives",
    points: [
      "```table",
      "Solution | Type | Best For",
      "Spring Cloud Config | Git-backed server | Spring Boot microservices",
      "Consul KV | HashiCorp key-value store | Multi-language environments",
      "AWS Parameter Store | Managed service | AWS-native applications",
      "Azure App Configuration | Managed service | Azure-native applications",
      "Kubernetes ConfigMaps | K8s-native | Kubernetes deployments",
      "Vault | HashiCorp secrets management | Security-focused environments",
      "```"
    ],
    keepInMind: "While Spring Cloud Config is excellent for Spring-based ecosystems, other tools may be better depending on your environment. For example, Kubernetes ConfigMaps are the standard for K8s deployments, and cloud-specific services like AWS Parameter Store integrate well with other cloud services."
  },
  {
    title: "Kubernetes ConfigMaps",
    points: [
      "**ConfigMap Definition:**",
      "```yaml",
      "apiVersion: v1",
      "kind: ConfigMap",
      "metadata:",
      "  name: user-service-config",
      "data:",
      "  application.yml: |",
      "    app:",
      "      name: User Service",
      "      version: 1.0.0",
      "    database:",
      "      url: jdbc:mysql://mysql:3306/userdb",
      "```",
      "**Mount as Volume:**",
      "```yaml",
      "spec:",
      "  containers:",
      "  - name: user-service",
      "    volumeMounts:",
      "    - name: config-volume",
      "      mountPath: /app/config",
      "  volumes:",
      "  - name: config-volume",
      "    configMap:",
      "      name: user-service-config",
      "```"
    ],
    keepInMind: "A ConfigMap is a Kubernetes object used to store non-confidential configuration data as key-value pairs. You can mount a ConfigMap as a volume into a pod, allowing the application to read the configuration from files without being tightly coupled to the Kubernetes environment."
  },
  {
    title: "Best Practices",
    points: [
      "‚úÖ Externalize all environment-specific configuration",
      "‚úÖ Use encryption for sensitive data",
      "‚úÖ Implement configuration validation",
      "‚úÖ Version control configuration changes",
      "‚úÖ Use profiles for environment separation",
      "‚úÖ Monitor configuration server health",
      "‚ùå Don't store secrets in plain text",
      "‚ùå Don't hardcode configuration in application code",
      "‚ùå Don't ignore configuration server failures"
    ],
    note: "üß† Interview tip: Explain the 12-factor app principle of configuration externalization",
    keepInMind: "Configuration should be treated as code with proper versioning, testing, and deployment practices."
  },
  {
    title: "Configuration Management Summary",
    points: [
      "‚öôÔ∏è **Purpose** - Centralized, externalized configuration management",
      "üåê **Spring Cloud Config** - Git-backed configuration server",
      "üìÅ **Repository Structure** - Hierarchical configuration files",
      "üîÑ **Dynamic Refresh** - Update configuration without restart",
      "üîê **Encryption** - Secure sensitive configuration data",
      "üéØ **Profiles** - Environment-specific configuration",
      "üîç **Service Discovery** - High-available configuration access",
      "‚ò∏Ô∏è **Alternatives** - Consul, Parameter Store, ConfigMaps",
      "üî• **Essential** for maintainable, scalable microservices"
    ],
    note: "üß† Configuration management enables environment-agnostic deployments",
    keepInMind: "Good configuration management is the foundation of a reliable, maintainable distributed system."
  }
];